<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Android on Jamie Craane personal blog</title>
    <link>https://jamiecraane.dev/tags/android/</link>
    <description>Recent content in Android on Jamie Craane personal blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 22 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://jamiecraane.dev/tags/android/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Jetpack Compose - Recompositions</title>
      <link>https://jamiecraane.dev/2022/11/13/compose_recompositions/</link>
      <pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://jamiecraane.dev/2022/11/13/compose_recompositions/</guid>
      <description>What is recomposition A Compose function in Jetpack Compose represents some UI to be rendered:
@Composable fun UsersScreen() { var usersScreenState by remember { mutableStateOf( UsersScreenState( title = &amp;#34;Users&amp;#34;, body = &amp;#34;This is the users screen&amp;#34;, (1..40).toList().map { Person(it, &amp;#34;Firstname Lastname $it&amp;#34;) }, ) ) } Column() { Text(usersScreenState.title) Text(usersScreenState.description) Button(onClick = { usersScreenState = usersScreenState.copy(title = Random.nextInt().toString()) }) { Text(&amp;#34;Change title&amp;#34;) } PersonList(usersScreenState.persons) } } Notice that the usersScreenState is a var which means it can change.</description>
    </item>
    
    <item>
      <title>Standalone KMM Images</title>
      <link>https://jamiecraane.dev/2022/07/27/standalone_kmm_images/</link>
      <pubDate>Thu, 22 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://jamiecraane.dev/2022/07/27/standalone_kmm_images/</guid>
      <description>Image by Dall-E: &amp;ldquo;Factory which produces lots of the same products. Dark.&amp;rdquo;
Context https://jamiecraane.dev/2021/07/27/resource_images_kmm/ describes how to use the kmm-images plugin to share images between a Kotlin Multiplatform Mobile (short KMM) Android and iOS app. You can also use kmm-images in a standalone Android app. This post describes the advantages of doing this.
Benefits of using kmm-images in an Android app Kmm-images unifies image handling in a KMM iOS and Android app.</description>
    </item>
    
    <item>
      <title>Koin ViewModel Injection</title>
      <link>https://jamiecraane.dev/2022/07/27/koin_viewmodel_injection/</link>
      <pubDate>Wed, 27 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://jamiecraane.dev/2022/07/27/koin_viewmodel_injection/</guid>
      <description>Image by Dall-E: &amp;ldquo;Inside of a large factory assembling robots from parts. The scene is somewhat dark with neon lights. cyberpunk style.&amp;rdquo;
Context A ViewModel in Android (not to be confused with the term ViewModel in the MVVM architecture pattern) is a component scoped to the lifecycle of another component, usually a fragment or an activity. To create maintainable code without becoming the ViewModel to large, the ViewModel delegates to other objects.</description>
    </item>
    
    <item>
      <title>Code re-usability</title>
      <link>https://jamiecraane.dev/2022/06/16/code_reusability/</link>
      <pubDate>Mon, 15 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://jamiecraane.dev/2022/06/16/code_reusability/</guid>
      <description>Re-usability within software development means to reuse (part of) a solution in different products with the aim of:
faster time to market lower costs less chance of introducing issues be able to use shared knowledge Re-usability at different abstraction levels Re-usability exists at many levels of abstraction in software development. Each abstraction offers some degree of advantages as well as disadvantages. Some examples, from high to low abstraction level:
Infrastructure Using infrastructure to distribute software.</description>
    </item>
    
    <item>
      <title>KMM adoption strategies</title>
      <link>https://jamiecraane.dev/2021/11/15/kmm_adoption_strategies/</link>
      <pubDate>Mon, 15 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://jamiecraane.dev/2021/11/15/kmm_adoption_strategies/</guid>
      <description>KMM adoption strategies Introduction Kotlin multiplatform Mobile, in short KMM, lets you write native cross platform mobile applications. It lets you share logic across iOS and Android while still leveraging all of the native features of the platform.
There are several advantages of sharing code between platforms:
Reduced development time More consistent logic across platforms More consistent behavior across platforms Less bugs Improved team communication KMM gives the flexibility to decide what code is shared.</description>
    </item>
    
    <item>
      <title>Localized resources and images in KMM</title>
      <link>https://jamiecraane.dev/2021/07/27/resource_images_kmm/</link>
      <pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://jamiecraane.dev/2021/07/27/resource_images_kmm/</guid>
      <description>Introduction Kotlin Multiplatform Mobile (in short KMM) allows you to share a lot of code which is normally duplicated across iOS and Android native platforms. KMM does not mandate that certain type of code is shared, it is up to you. It also does not mandate any particular architecture.
Although KMM enables sharing of code between platforms it does not provide the ability to share localized string resources and images out-of-the box between iOS and Android.</description>
    </item>
    
    <item>
      <title>Casting images with Chromecast</title>
      <link>https://jamiecraane.dev/2021/01/05/android_chromecast_images/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://jamiecraane.dev/2021/01/05/android_chromecast_images/</guid>
      <description>Full source code can be found here: https://github.com/jcraane/android-simple-image-cast
By adding Chromecast support to media rich apps like photo- and video players, users can display content to Chromecast enabled devices. This greatly enhances the user experience of those apps.
This post demonstrates how to integrate the Chromecast SDK to add cast support for casting images. The app displays a list of publicly available images using an image carousel. When the user scrolls through those images, the images are cast to a connected receiver.</description>
    </item>
    
  </channel>
</rss>
